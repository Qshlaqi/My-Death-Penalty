# مستندات فنی نرم‌افزار دیباگر ربات

## مقدمه

این سند به تشریح معماری فنی نرم‌افزار دیباگر ربات می‌پردازد. هدف اصلی این مستندات، راهنمایی توسعه‌دهندگان برای درک ساختار فعلی برنامه، به ویژه پس از بازآفرینی سیستم ارتباطی آن برای حل مشکل هنگ کردن در فرکانس‌های بالای دریافت داده است.

## معماری نرم‌افزار

نرم‌افزار با استفاده از کتابخانه **PySide6** برای رابط کاربری (UI) و به زبان پایتون نوشته شده است. معماری کلیدی برنامه بر پایه **چند نخی (Multi-threading)** استوار است تا از پاسخگو بودن (responsiveness) رابط کاربری در حین دریافت حجم بالای داده از ربات اطمینان حاصل شود.

این معماری از دو ترد اصلی تشکیل شده است:

1.  **ترد اصلی (GUI Thread):**
    *   این ترد، ترد پیش‌فرض هر اپلیکیشن Qt است و مسئولیت مدیریت تمام اجزای رابط کاربری، رویدادها (کلیک، ورودی کاربر) و بازрисов پنجره‌ها را بر عهده دارد.
    *   **قانون طلایی:** هیچ عملیات طولانی، مسدودکننده (blocking) یا زمان‌بری نباید در این ترد اجرا شود. این شامل عملیات شبکه، دسترسی به فایل‌های حجیم و محاسبات سنگین می‌شود.

2.  **ترد کارگر (Worker Thread):**
    *   یک `QThread` جداگانه که مسئولیت کامل مدیریت ارتباط **وب‌ساکت (WebSocket)** با ربات را بر عهده دارد.
    *   تمام عملیات شبکه، از جمله برقراری اتصال، گوش دادن مداوم به پیام‌های دریافتی و ارسال دستورات به ربات، در این ترد انجام می‌شود.
    *   این جداسازی تضمین می‌کند که حتی اگر ربات با فرکانس بسیار بالا (مثلاً ۱۸۰ هرتز) داده ارسال کند، ترد اصلی هرگز مسدود نشده و برنامه هنگ نمی‌کند.

### نحوه ارتباط بین تردها

ارتباط امن و استاندارد بین ترد اصلی و ترد کارگر از طریق مکانیزم **سیگنال و اسلات (Signals & Slots)** کتابخانه Qt انجام می‌شود:

*   **از کارگر به اصلی:** کلاس `WebsocketWorker` (که در ترد کارگر اجرا می‌شود) سیگنال‌هایی مانند `data_received(dict)`، `connected()` و `error_occurred(str)` را منتشر (emit) می‌کند. کلاس اصلی `ClientGUI` به این سیگنال‌ها متصل (connect) شده و توابع (اسلات‌های) مربوطه را در **ترد اصلی** اجرا می‌کند. این روش، امن‌ترین راه برای به‌روزرسانی UI از یک ترد دیگر است.

*   **از اصلی به کارگر:** فراخوانی متدهای کارگر به صورت مستقیم انجام نمی‌شود. به جای آن، از طریق سیگنال‌ها یا فراخوانی متدهایی که در ترد کارگر اجرا می‌شوند (با استفاده از `QMetaObject.invokeMethod` یا اتصال سیگنال به اسلات) دستورات ارسال می‌شوند. در پیاده‌سازی فعلی، متد `send_message` در کارگر برای ارسال داده استفاده می‌شود.

### کنترل فرکانس به‌روزرسانی (Throttling)

حتی با وجود ترد جداگانه، به‌روزرسانی مداوم UI با فرکانس ۱۸۰ هرتز غیرضروری و پرهزینه است. برای بهینه‌سازی این فرآیند:

1.  یک متغیر (`latest_data`) در کلاس `ClientGUI` آخرین بسته داده دریافتی از ترد کارگر را ذخیره می‌کند.
2.  یک `QTimer` در ترد اصلی با فرکانس ثابت و معقول (مثلاً ۳۰ هرتز) اجرا می‌شود.
3.  با هر بار تیک خوردن تایمر، تابع `throttled_ui_update` فراخوانی شده و رابط کاربری را فقط بر اساس **آخرین** داده‌های موجود به‌روزرسانی می‌کند.

این مکانیزم باعث می‌شود که برنامه بسیار روان‌تر اجرا شده و از بار اضافی بر روی CPU و GPU جلوگیری شود.

## راهنمای اجرا

برای اجرای پروژه، ابتدا وابستگی‌های مورد نیاز را نصب کنید:

```bash
pip install PySide6 websocket-client
```

سپس، فایل اصلی برنامه را اجرا کنید:

```bash
python main.py
```

## ساختار فایل‌ها

*   `main.py`: نقطه ورود اصلی برنامه. کلاس `ClientGUI` که پنجره اصلی را مدیریت می‌کند در اینجا قرار دارد.
*   `websocket_worker.py`: حاوی کلاس `WebsocketWorker` است که تمام منطق ارتباط شبکه را در خود کپسوله کرده است.
*   `frontpage.py`, `debug_page2.py`, ...: فایل‌های مربوط به بخش‌های مختلف رابط کاربری.
*   `*.ui`: فایل‌های طراحی رابط کاربری که با Qt Designer ساخته شده‌اند.
